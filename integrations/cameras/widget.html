{# Camera surveillance grid - Command Center style #}
<div class="h-full flex flex-col">
  {# Widget header with telemetry #}
  <div
    class="flex items-center justify-between mb-3 pb-2 border-b border-command-border"
  >
    <div class="flex items-center gap-3">
      <div class="w-1 h-4 bg-command-amber"></div>
      <h2 class="text-sm font-bold tracking-wider text-white uppercase">
        Surveillance_Grid
      </h2>
    </div>
    <div class="text-xs tracking-wider">
      <span class="text-command-cyan opacity-60">ACTIVE</span>
      <span class="font-bold text-command-amber ml-1"
        >{{ '%02d'|format(data.cameras|selectattr('status', 'equalto',
        'online')|list|length) }}</span
      >
    </div>
  </div>

  {# Camera grid - custom layout #}
  <div class="flex-1 grid gap-2 overflow-y-auto pr-1 camera-grid">
    {% for camera in data.cameras if camera.status == 'online' %}
    <div
      class="bg-command-darker border border-command-border flex flex-col relative group hover:border-command-cyan/40 transition-colors camera-item"
      data-camera-name="{{ camera.name }}"
    >
      {# Camera header with status telemetry #}
      <div
        class="bg-command-black/90 px-2 py-1.5 flex items-center justify-between border-b border-command-border"
      >
        <span class="text-xs font-bold text-white tracking-wider uppercase"
          >{{ camera.name }}</span
        >
        <div class="flex items-center gap-2">
          {% if camera.motion_detected %}
          <div class="flex items-center gap-1 motion-alert">
            <div class="w-1.5 h-1.5 bg-command-amber rounded-full"></div>
            <span
              class="text-[0.7rem] text-command-amber font-mono tracking-wider"
              >MOTION</span
            >
          </div>
          {% endif %} {% if camera.is_recording %}
          <div
            class="w-1.5 h-1.5 bg-command-red rounded-full animate-glow-pulse status-indicator"
            title="Recording"
          ></div>
          {% endif %}
          <div
            class="w-1.5 h-1.5 rounded-full {{ 'bg-command-green' if camera.status == 'online' else 'bg-command-border' }} status-indicator"
            title="{{ camera.status|capitalize }}"
          ></div>
        </div>
      </div>

      {# Video stream container - WebRTC only #}
      <div
        class="relative bg-command-black camera-stream-container"
        data-camera-id="{{ camera.id }}"
        data-camera-name="{{ camera.name }}"
        data-webrtc-url="{{ camera.webrtc_url }}"
      >
        {# WebRTC video element #}
        <video
          id="video-webrtc-{{ camera.id }}"
          class="w-full h-auto object-contain stream-webrtc"
          autoplay
          playsinline
          muted
        ></video>

        {# Corner frame overlay for active feed #}
        <div
          class="absolute inset-0 pointer-events-none opacity-0 group-hover:opacity-100 transition-opacity"
        >
          <div
            class="absolute top-0 left-0 w-3 h-3 border-l border-t border-command-cyan"
          ></div>
          <div
            class="absolute top-0 right-0 w-3 h-3 border-r border-t border-command-cyan"
          ></div>
          <div
            class="absolute bottom-0 left-0 w-3 h-3 border-l border-b border-command-cyan"
          ></div>
          <div
            class="absolute bottom-0 right-0 w-3 h-3 border-r border-b border-command-cyan"
          ></div>
        </div>
      </div>

      {# Camera info footer with telemetry data #}
      <div
        class="bg-command-black/70 px-2 py-1 text-[0.65rem] text-command-cyan/60 flex justify-between border-t border-command-border font-mono tracking-wider"
      >
        <span class="uppercase">{{ camera.model or 'UNKNOWN' }}</span>
        <span>{{ camera.resolution or '--' }}</span>
      </div>
    </div>
    {% endfor %}
  </div>

  {# Recent motion events log #} {% if data.recent_motion_events %}
  <div class="mt-3 pt-2 border-t border-command-border">
    <div class="flex items-center gap-2 mb-1.5">
      <div class="w-0.5 h-2.5 bg-command-amber"></div>
      <h3
        class="text-xs font-bold tracking-widest text-command-amber uppercase"
      >
        Motion_Log
      </h3>
      <div
        class="flex-1 h-px bg-gradient-to-r from-command-amber/30 to-transparent"
      ></div>
    </div>
    <div class="space-y-0.5 max-h-20 overflow-y-auto pr-1">
      {% for event in data.recent_motion_events[:5] %}
      <div
        class="flex justify-between text-[0.7rem] font-mono tracking-wider bg-command-darker/40 px-2 py-1"
      >
        <span class="text-command-cyan/80">{{ event.camera_name }}</span>
        <span class="text-command-amber/60"
          >{{ event.timestamp.strftime('%H:%M:%S') }}</span
        >
      </div>
      {% endfor %}
    </div>
  </div>
  {% endif %}
</div>

<style>
  /* Custom camera grid layout */
  .camera-grid {
    grid-template-columns: repeat(2, 1fr);
    grid-auto-rows: min-content;
    align-content: start;
  }

  /* Front Doorbell: Full width on top, but constrained */
  .camera-item[data-camera-name*="DOORBELL"],
  .camera-item[data-camera-name*="Doorbell"],
  .camera-item[data-camera-name*="doorbell"] {
    grid-column: 1 / -1;
    grid-row: 1;
  }

  /* Doorbell camera video: constrained height, maintains 4:3 ratio */
  .camera-item[data-camera-name*="DOORBELL"] .stream-webrtc,
  .camera-item[data-camera-name*="Doorbell"] .stream-webrtc,
  .camera-item[data-camera-name*="doorbell"] .stream-webrtc {
    max-height: 280px;
  }

  /* Bottom row cameras: smaller, maintains 16:9 ratio */
  .camera-item[data-camera-name*="DRIVEWAY"] .stream-webrtc,
  .camera-item[data-camera-name*="Driveway"] .stream-webrtc,
  .camera-item[data-camera-name*="driveway"] .stream-webrtc,
  .camera-item[data-camera-name*="PORCH"] .stream-webrtc,
  .camera-item[data-camera-name*="Porch"] .stream-webrtc,
  .camera-item[data-camera-name*="porch"] .stream-webrtc {
    max-height: 180px;
  }

  /* Driveway: Bottom left */
  .camera-item[data-camera-name*="DRIVEWAY"],
  .camera-item[data-camera-name*="Driveway"],
  .camera-item[data-camera-name*="driveway"] {
    grid-column: 1;
    grid-row: 2;
  }

  /* Front Porch: Bottom right */
  .camera-item[data-camera-name*="PORCH"],
  .camera-item[data-camera-name*="Porch"],
  .camera-item[data-camera-name*="porch"] {
    grid-column: 2;
    grid-row: 2;
  }

  /* Any other cameras: flow naturally */
  .camera-item:not([data-camera-name*="DOORBELL"]):not(
      [data-camera-name*="Doorbell"]
    ):not([data-camera-name*="doorbell"]):not(
      [data-camera-name*="DRIVEWAY"]
    ):not([data-camera-name*="Driveway"]):not(
      [data-camera-name*="driveway"]
    ):not([data-camera-name*="PORCH"]):not([data-camera-name*="Porch"]):not(
      [data-camera-name*="porch"]
    ) {
    grid-column: auto;
    grid-row: auto;
  }
</style>

<script>
  // Track connected cameras globally - survives DOM updates
  window._connectedCameras = window._connectedCameras || new Set();

  // Store loading overlays globally so they survive DOM morphs
  window._loadingOverlays = window._loadingOverlays || new Map();

  // WebRTC stream management
  class CameraStreamer {
    constructor(container) {
      this.container = container;
      this.cameraId = container.dataset.cameraId;
      this.cameraName = container.dataset.cameraName;
      this.webrtcUrl = container.dataset.webrtcUrl;

      this.videoWebRTC = container.querySelector(".stream-webrtc");

      // Create or reuse loading overlay (not in server HTML)
      this.loadingOverlay = this._getOrCreateOverlay();

      this.pc = null;
      this.ws = null;
    }

    _getOrCreateOverlay() {
      // Check if we already have an overlay for this camera
      let overlay = window._loadingOverlays.get(this.cameraId);

      if (!overlay || !document.contains(overlay)) {
        // Create new overlay with command center styling
        overlay = document.createElement("div");
        overlay.className =
          "absolute inset-0 flex items-center justify-center bg-command-black/90 loading-overlay border border-command-border/30";
        const text = document.createElement("div");
        text.className =
          "text-command-cyan text-xs font-mono tracking-widest animate-pulse";
        text.textContent = "CONNECTING...";
        overlay.appendChild(text);
        window._loadingOverlays.set(this.cameraId, overlay);
      }

      // Append to current container (might be new DOM from morph)
      this.container.appendChild(overlay);

      // Hide if already connected
      if (window._connectedCameras.has(this.cameraId)) {
        overlay.classList.add("hidden");
      }

      return overlay;
    }

    async start() {
      if (!this.webrtcUrl) return;

      try {
        this.loadingOverlay.classList.remove("hidden");

        // Create peer connection (matching go2rtc's implementation)
        this.pc = new RTCPeerConnection({
          iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
        });

        // Add transceivers and create MediaStream from receiver tracks
        const videoTrack = this.pc.addTransceiver("video", {
          direction: "recvonly",
        }).receiver.track;
        const audioTrack = this.pc.addTransceiver("audio", {
          direction: "recvonly",
        }).receiver.track;
        this.videoWebRTC.srcObject = new MediaStream([videoTrack, audioTrack]);

        // Hide loading when video starts playing
        this.videoWebRTC.onloadeddata = () => {
          this.loadingOverlay.classList.add("hidden");
          window._connectedCameras.add(this.container.dataset.cameraId);
        };

        // Connect to go2rtc WebSocket
        this.ws = new WebSocket(this.webrtcUrl);

        // Send local ICE candidates to go2rtc
        this.pc.onicecandidate = (event) => {
          if (event.candidate && this.ws.readyState === WebSocket.OPEN) {
            this.ws.send(
              JSON.stringify({
                type: "webrtc/candidate",
                value: event.candidate.candidate,
              }),
            );
          }
        };

        this.ws.onopen = async () => {
          // Create and send offer after WebSocket is open
          const offer = await this.pc.createOffer();
          await this.pc.setLocalDescription(offer);
          this.ws.send(
            JSON.stringify({
              type: "webrtc/offer",
              value: offer.sdp,
            }),
          );
        };

        this.ws.onmessage = async (event) => {
          const msg = JSON.parse(event.data);
          if (msg.type === "webrtc/answer") {
            await this.pc.setRemoteDescription({
              type: "answer",
              sdp: msg.value,
            });
          } else if (msg.type === "webrtc/candidate") {
            await this.pc.addIceCandidate({
              candidate: msg.value,
              sdpMid: "0",
            });
          }
        };

        this.ws.onerror = () => {
          const errorDiv = document.createElement("div");
          errorDiv.className =
            "text-command-red text-xs font-mono tracking-widest";
          errorDiv.textContent = "CONNECTION_FAILED";
          this.loadingOverlay.replaceChildren(errorDiv);
        };
      } catch (error) {
        console.error("WebRTC error:", error);
        const errorDiv = document.createElement("div");
        errorDiv.className =
          "text-command-red text-xs font-mono tracking-widest";
        errorDiv.textContent = "ERROR";
        this.loadingOverlay.replaceChildren(errorDiv);
      }
    }

    stop() {
      if (this.pc) {
        this.pc.close();
        this.pc = null;
      }
      if (this.ws) {
        this.ws.close();
        this.ws = null;
      }
      if (this.videoWebRTC.srcObject) {
        this.videoWebRTC.srcObject.getTracks().forEach((track) => track.stop());
        this.videoWebRTC.srcObject = null;
      }
      this.loadingOverlay.classList.remove("hidden");
      window._connectedCameras.delete(this.container.dataset.cameraId);
    }
  }

  // Use global storage to persist streams across widget re-renders
  window._cameraStreams = window._cameraStreams || new Map();

  document.querySelectorAll(".camera-stream-container").forEach((container) => {
    const cameraId = container.dataset.cameraId;
    const hasVideoElements = container.querySelector(".stream-webrtc") !== null;
    if (!hasVideoElements) return;

    const existingStream = window._cameraStreams.get(cameraId);

    if (
      existingStream &&
      existingStream.pc &&
      existingStream.pc.connectionState !== "closed" &&
      existingStream.pc.connectionState !== "failed"
    ) {
      // Reattach existing stream to new DOM elements
      const videoEl = container.querySelector(".stream-webrtc");
      const loadingOverlay = container.querySelector(".loading-overlay");

      // Reattach srcObject if available
      if (existingStream.srcObject) {
        videoEl.srcObject = existingStream.srcObject;
      }

      // Always hide loading overlay for active connections
      if (loadingOverlay) loadingOverlay.classList.add("hidden");
    } else {
      // Create new streamer for this camera
      const streamer = new CameraStreamer(container);
      streamer.start();

      // Store reference to the stream
      window._cameraStreams.set(cameraId, {
        pc: streamer.pc,
        ws: streamer.ws,
        srcObject: null,
        streamer: streamer,
      });

      // Update srcObject reference when stream connects
      const videoEl = container.querySelector(".stream-webrtc");
      const observer = new MutationObserver(() => {
        if (videoEl.srcObject) {
          const stored = window._cameraStreams.get(cameraId);
          if (stored) stored.srcObject = videoEl.srcObject;
        }
      });
      observer.observe(videoEl, { attributes: true, attributeFilter: ["src"] });

      // Also check periodically for srcObject
      const checkStream = setInterval(() => {
        if (videoEl.srcObject) {
          const stored = window._cameraStreams.get(cameraId);
          if (stored) stored.srcObject = videoEl.srcObject;
          clearInterval(checkStream);
        }
      }, 100);
      setTimeout(() => clearInterval(checkStream), 10000);
    }
  });
</script>
